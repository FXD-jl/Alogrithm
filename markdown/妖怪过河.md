### 问题描述
> “有三个和尚和三个妖怪（也可翻译为传教士和食人妖）要利用唯一一条小船过河，这条小船一次只能载两个人，同时，无论是在河的两岸还是在船上，只要妖怪的数量大于和尚的数量，妖怪们就会将和尚吃掉。现在需要选择一种过河的安排，保证和尚和妖怪都能过河且和尚不能被妖怪吃掉。”
>> 摘录来自 [算法的乐趣]王晓华

### 解题思路

1.构建状态模型图  
[3,3,0,0,LOCAL] -> [0,0,3,3,REMOTE]  
> 这里3,3表示河岸的妖怪与和尚的数量。  
这里0,0表示河对岸的妖怪与和尚的数量。  
这里LOCAL表示小船在河岸。  
这里REMOTE表示小船在河对岸。  
船的位置决定了状态转移的方向

ps: *计算的本质是从一个状态转移到另一个状态,计算机本质是计算强  
要让计算机明白问题可以以状态及其变动来描述问题，起始是什么状态  
终止时什么状态，这个状态图哪里可以简化*

2.构建状态转移方程
> 穷举算法  
> 1.描述问题  
> 2.初始化状态  
> 3.状态转移函数，  
应该是船的状态以及选择的方法（4种）  
同时，要构建一个检查函数来剪枝/添加一个方案,状态应该在  
栈中方便回溯。  
> 4.求解  
要构建一个检查函数来剪枝/添加一个方案,状态应该在栈中方便回溯。  
> 5.结束  
当栈为空时，结束


### 深度优先遍历和广度优先遍历对比
> 深度优先遍历（DFS）和广度优先遍历（BFS）是两种遍历图或树中的所有顶点的算法。
深度优先遍历（DFS）：
选取一个节点开始，沿着一条路一直走到底，然后从这条路尽头的节点回退到上一个节点，再从另一条路开始走到底…，不断递归重复此过程，直到所有的顶点都遍历完成。
实现方式：回溯（利用栈的先入后出特性）和递归遍历。
广度优先遍历（BFS）：
从图的一个未遍历的节点出发，先遍历这个节点的相邻节点，再依次遍历每个相邻节点的相邻节点。
实现方式：重放（利用队列的先入先出特性）1。
深度优先遍历不全部保留结点，扩展完的结点从数据库中弹出删去，这样，一般在数据库中存储的结点数就是深度值，因此它占用空间较少。而广度优先搜索算法，一般需存储产生的所有结点，占用的存储空间要比深度优先搜索大得多，因此，程序设计中，必须考虑溢出和节省内存空间的问题23。但广度优先搜索法一般无回溯操作，即入栈和出栈的操作，所以运行速度比深度优先搜索要快些3。

*综上所述，选择深度优先遍历还是广度优先遍历，取决于具体的应用场景和需求.*

### 作者采用的正是深度遍历算法  
1.构建状态并压入栈中  
2.剪枝与去掉重复状态  
3.保存成功的路径  
> 作者提出为了避免过多的使用if switch等语句，应该试着将动作统一化。
