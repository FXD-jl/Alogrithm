
1.构建数据结构，来表示初始状态与终止状态
```c
[3,3,0,0,LOACL/REMOTE] -> [岸上妖怪,岸上和尚,对岸妖怪,对岸和尚，船的位置]

Typedef struct Statue_{


}Statue


```
2.选择深度搜索，那么状态转移，剪枝与去重，保存正确路径  
> 状态转移：简单的将数据规整化以避免if，switch的大量使用  
然后将所以状态压入栈中  
剪枝、去重、保持正确路径分别设置相应的检查函数。三者都会  
涉及栈的操作，出栈意味着回溯，入栈意味着进一步深入。大的  
终止条件，栈为空
>
>记录结果，首先要定义记录什么样的结果。这里定义为：移动的过程
,一共有10种可能得移动过程，[ONE_MONSTER_GO,REMOTE,-1,0]  
[ONE_MONSTER_BACK, LOCAL, 1,0],因为两边只需要考虑一边就够了，  
只要在某个时刻[x,REMOTE,0,0]这个状态就说明达到目标  
这样理解算法：（涂上黑色表示出栈，白色表示未出栈）
状态栈是记录的树的根节点及叶节点组成一条路径,想象为从根长出了  
一条茎叶。状态是茎叶上的节点
记录栈是记录长出茎叶时节点间的茎脉。  
action栈记录的是依附于节点的未使用的茎脉，因此当所以依附的节点都  
涂成了黑色，则对应的节点需要从状态中弹出 -> 
新的想法：树是具有分形结构的，也就是可以用递归的方法。  
递归算法：  
利用分形的观点，将对应的记录栈作为参数即可
>
> 结合C语言考虑内存管理问题，考虑到时树，状态栈的每一个节点以及  
action栈的每一个节点都应该在栈上分配，然后指针相互连接，  
以便最后回收，同时对应剔除的节点删除掉，并处理管理链，内存的  
所有权在栈上，其他使用者可以引用，并为管理链创建新的节点。


